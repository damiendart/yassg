#!/usr/bin/env node
// Copyright (C) 2019-2021 Damien Dart, <damiendart@pobox.com>.
// This file is distributed under the MIT licence. For more information,
// please refer to the accompanying "LICENCE" file.

/* eslint no-console: 0 global-require: 0 */
/* eslint-env node */

const fse = require('fs-extra');
const glob = require('util').promisify(require('glob'));
const path = require('path');

const NoOpProcessor = require('../src/processors/NoOpProcessor');
const processors = [
  require('../src/processors/MarkdownProcessor'),
  NoOpProcessor,
  require('../src/processors/TwigProcessor'),
];

let processHiddenFiles = false;

if (
  process.argv.length < 4
  || process.argv.includes('--help')
  || process.argv.includes('-h')
) {
  const askingForHelp = process.argv.includes('--help')
    || process.argv.includes('-h');

  (askingForHelp ? console.log : console.error)(
    `"${path.basename(process.argv[1])}" is a real basic static site generator.
    Usage: ${path.basename(process.argv[1])} INPUT-DIRECTORY OUTPUT-DIRECTORY`
      .trim().replace(/\n {4}/g, '\n'),
  );
  process.exit(askingForHelp ? 0 : 1);
}

if (process.argv.includes('--hidden')) {
  processHiddenFiles = true;
  process.argv = process.argv.filter(
    (value) => value !== '--hidden',
  );
}

const config = { globalData: {}, modifiers: [] };
const inputBaseDirectoryPath = path.resolve(process.argv[2]);
const outputBaseDirectoryPath = path.resolve(process.argv[3]);
let writtenFileCount = 0;

try {
  Object.assign(
    config,
    // eslint-disable-next-line import/no-dynamic-require
    require(`${inputBaseDirectoryPath}/.buildstatic.conf`),
  );
} catch (e) {
  if (e.code === 'MODULE_NOT_FOUND') {
    console.error('[!] No ".buildstatic.conf.js" found in input directory');
  } else {
    console.error(
      `[✘] Unable to process "${inputBaseDirectoryPath}/.buildconfig.conf.js!\n`,
    );
    console.error(e);
    process.exit(1);
  }
}

config.globalData.inputBaseDirectoryPath = inputBaseDirectoryPath;
config.globalData.outputBaseDirectoryPath = outputBaseDirectoryPath;

glob('**/*', { cwd: inputBaseDirectoryPath, dot: processHiddenFiles, nodir: true })
  .then((files) => files.map((file) => {
    const applicableProcessors = processors.filter(
      (processor) => processor.INPUT_EXTENSION === path.extname(file),
    );
    const inputFilePath = path.join(inputBaseDirectoryPath, file);

    if (applicableProcessors.length === 0) {
      applicableProcessors.push(NoOpProcessor);
    }

    return applicableProcessors.map((processor) => ({
      data: {
        content: processor.name !== 'NoOpProcessor'
          ? fse.readFileSync(inputFilePath).toString()
          : null,
        inputFilePath,
        outputFilePath: path.join(outputBaseDirectoryPath, file)
          .replace(processor.INPUT_EXTENSION, processor.OUTPUT_EXTENSION),
      },
      processor,
    }));
  }))
  .then((items) => items.flat().map(
    (item) => {
      const preprocessedItem = item;

      preprocessedItem.data = item.processor.preprocess(item.data);

      return preprocessedItem;
    },
  ))
  .then((items) => {
    let modifiedItems = items;

    config.modifiers.forEach((modifier) => {
      let modifierFunction;
      let options = {};

      if (Array.isArray(modifier)) {
        [modifierFunction, options] = modifier;
      } else {
        modifierFunction = modifier;
      }

      [config.globalData, modifiedItems] = modifierFunction(
        config.globalData,
        modifiedItems,
        options,
      );
    });

    return modifiedItems;
  })
  .then((items) => Promise.all(
    items.map((item) => {
      let action;

      if (item.processor.name === 'NoOpProcessor') {
        action = fse.copy(item.data.inputFilePath, item.data.outputFilePath);
      } else {
        action = fse.mkdirs(path.dirname(item.data.outputFilePath))
          .then(() => item.processor.process(
            { ...config.globalData, ...item.data },
          ))
          .then((output) => fse.writeFile(
            item.data.outputFilePath,
            output,
          ));
      }

      return action
        .then(() => {
          console.log(`[✔] Written "${item.data.outputFilePath}"`);
          writtenFileCount += 1;
        })
        .catch((e) => {
          console.error(`[✘] Unable to write "${item.data.outputFilePath}"\n`);
          console.error(e);
          process.exit(1);
        });
    }),
  ))
  .then(() => {
    console.log(`\n${writtenFileCount} file(s) written!`);
  })
  .catch((e) => {
    console.error('[✘] An error has occurred!\n');
    console.error(e);
    process.exit(1);
  });
